<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
  <title>è¿è¿çœ‹ï¼ˆæ‰‹æœºå¯ç©ï¼‰</title>
  <style>
    :root{
      --bg:#0b1220;
      --panel:#101a2f;
      --tile:#162447;
      --tile2:#0f1a33;
      --text:#e7eeff;
      --muted:#9fb3e6;
      --accent:#5eead4;
      --danger:#fb7185;
      --line:#fbbf24;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 14px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "PingFang SC", "Microsoft YaHei", Arial;
      background: radial-gradient(1200px 800px at 30% 10%, #172554 0%, var(--bg) 55%, #020617 100%);
      color:var(--text);
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 18px 12px 28px;
    }
    .app{
      width:min(980px, 100%);
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }
    header{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border: 1px solid rgba(255,255,255,.08);
      border-radius: var(--radius);
      padding: 12px 12px;
      box-shadow: var(--shadow);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
    }
    .title{
      display:flex;
      flex-direction:column;
      gap:2px;
      min-width: 180px;
    }
    .title h1{
      font-size: 16px;
      margin:0;
      letter-spacing:.5px;
    }
    .title small{
      color:var(--muted);
      font-size: 12px;
    }
    .stats{
      display:flex;
      gap: 8px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .chip{
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.09);
      padding: 8px 10px;
      border-radius: 999px;
      font-size: 12px;
      color: var(--muted);
      display:flex;
      align-items:center;
      gap:6px;
      user-select:none;
    }
    .chip b{color:var(--text); font-weight:700}
    .row{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }
    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border: 1px solid rgba(255,255,255,.08);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 10px;
      position:relative;
      overflow:hidden;
    }
    .controls{
      display:flex;
      gap: 10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
      padding: 10px;
      border-radius: var(--radius);
      background: rgba(255,255,255,.03);
      border: 1px solid rgba(255,255,255,.06);
    }
    .btns{
      display:flex;
      gap: 8px;
      flex-wrap:wrap;
    }
    button{
      border:0;
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(94,234,212,.12);
      color: var(--text);
      border: 1px solid rgba(94,234,212,.25);
      font-weight: 650;
      letter-spacing:.2px;
      box-shadow: 0 8px 22px rgba(0,0,0,.22);
      cursor:pointer;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    button.secondary{
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.12);
      font-weight: 600;
      color: var(--muted);
    }
    button.danger{
      background: rgba(251,113,133,.12);
      border: 1px solid rgba(251,113,133,.22);
    }
    button:active{transform: translateY(1px)}
    .hint{
      color: var(--muted);
      font-size: 12px;
      line-height: 1.35;
      flex:1;
      min-width: 220px;
    }

    /* Game area */
    .gameWrap{
      position:relative;
      width:100%;
      aspect-ratio: 1 / 1;
      max-height: 78vh;
      margin: 0 auto;
    }

    .grid{
      position:absolute;
      inset:0;
      display:grid;
      gap: 8px;
      padding: 10px;
      border-radius: 18px;
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border: 1px solid rgba(255,255,255,.06);
    }

    .tile{
      border-radius: 16px;
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
      border: 1px solid rgba(255,255,255,.09);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: clamp(18px, 4vw, 28px);
      user-select:none;
      -webkit-user-select:none;
      cursor:pointer;
      touch-action: manipulation;
      position:relative;
      overflow:hidden;
      transition: transform .08s ease, box-shadow .12s ease, border-color .12s ease, background .12s ease;
      -webkit-tap-highlight-color: transparent;
    }
    .tile::after{
      content:"";
      position:absolute;
      inset:-40% -40%;
      background: radial-gradient(closest-side, rgba(94,234,212,.22), transparent 65%);
      opacity:0;
      transform: translate3d(0,0,0);
      transition: opacity .15s ease;
      pointer-events:none;
    }
    .tile:hover{transform: translateY(-1px)}
    .tile.selected{
      border-color: rgba(94,234,212,.6);
      box-shadow: 0 0 0 2px rgba(94,234,212,.22), 0 14px 30px rgba(0,0,0,.30);
      background: rgba(94,234,212,.08);
    }
    .tile.selected::after{opacity:1}
    .tile.removed{
      visibility:hidden;
      pointer-events:none;
    }
    .tile.bad{
      animation: shake .18s linear 0s 2;
      border-color: rgba(251,113,133,.6);
    }
    @keyframes shake{
      0%{transform: translateX(0)}
      25%{transform: translateX(-2px)}
      50%{transform: translateX(2px)}
      75%{transform: translateX(-2px)}
      100%{transform: translateX(0)}
    }

    canvas{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      pointer-events:none;
    }

    .toast{
      position: fixed;
      left: 50%;
      bottom: 22px;
      transform: translateX(-50%);
      background: rgba(15,23,42,.92);
      border: 1px solid rgba(255,255,255,.12);
      padding: 10px 12px;
      border-radius: 999px;
      font-size: 13px;
      color: var(--text);
      box-shadow: var(--shadow);
      opacity:0;
      transition: opacity .18s ease, transform .18s ease;
      z-index: 9999;
      max-width: min(520px, 92vw);
      text-align:center;
    }
    .toast.show{
      opacity:1;
      transform: translateX(-50%) translateY(-4px);
    }

    .overlay{
      position:absolute;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background: rgba(2,6,23,.55);
      backdrop-filter: blur(6px);
      z-index: 30;
    }
    .overlay.show{display:flex}
    .card{
      width:min(520px, 92%);
      background: rgba(16,26,47,.92);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 18px;
      padding: 16px;
      box-shadow: var(--shadow);
      text-align:center;
    }
    .card h2{margin:0 0 8px; font-size: 18px}
    .card p{margin: 0 0 12px; color: var(--muted); font-size: 13px; line-height:1.45}
    .card .cardBtns{display:flex; gap:10px; justify-content:center; flex-wrap:wrap}

    @media (min-width: 880px){
      .row{grid-template-columns: 1.5fr 1fr;}
      .gameWrap{aspect-ratio: 1.15 / 1; max-height: 76vh;}
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="title">
        <h1>è¿è¿çœ‹ï¼ˆç½‘é¡µç«¯ / æ‰‹æœºå¯ç©ï¼‰</h1>
        <small>è§„åˆ™ï¼šä¸¤å¼ ç›¸åŒå›¾æ¡ˆï¼Œä¸”è¿çº¿ä¸è¶…è¿‡ 2 æ¬¡æ‹å¼¯å³å¯æ¶ˆé™¤</small>
      </div>
      <div class="stats">
        <div class="chip">â±ï¸ æ—¶é—´ï¼š<b id="time">00:00</b></div>
        <div class="chip">ğŸ‘£ æ­¥æ•°ï¼š<b id="moves">0</b></div>
        <div class="chip">ğŸ§© å‰©ä½™ï¼š<b id="left">0</b></div>
        <div class="chip">âœ¨ è¿æ¶ˆï¼š<b id="combo">0</b></div>
      </div>
    </header>

    <div class="row">
      <div class="panel">
        <div class="controls">
          <div class="btns">
            <button id="restart">é‡å¼€</button>
            <button id="shuffle" class="secondary">æ´—ç‰Œ</button>
            <button id="hint" class="secondary">æç¤º</button>
            <button id="pause" class="secondary">æš‚åœ</button>
            <button id="help" class="secondary">ç©æ³•</button>
          </div>
          <div class="hint">
            æ‰‹æœºæ“ä½œï¼šç‚¹ä¸€å¼  â†’ å†ç‚¹åŒå›¾æ¡ˆå¦ä¸€å¼ ï¼ˆèƒ½è¿é€šå°±æ¶ˆé™¤ï¼‰ã€‚<br/>
            å°æŠ€å·§ï¼šæ´—ç‰Œå¯è§£å†³â€œæ— è§£â€å±€é¢ï¼›æç¤ºä¼šé«˜äº®ä¸€å¯¹å¯æ¶ˆé™¤çš„ã€‚
          </div>
        </div>

        <div class="gameWrap" id="gameWrap">
          <canvas id="line"></canvas>
          <div class="grid" id="grid"></div>
          <div class="overlay" id="overlay">
            <div class="card">
              <h2 id="overlayTitle">æš‚åœä¸­</h2>
              <p id="overlayText">ç‚¹å‡»ç»§ç»­æˆ–é‡å¼€æ¸¸æˆã€‚</p>
              <div class="cardBtns">
                <button id="resume">ç»§ç»­</button>
                <button id="restart2" class="danger">é‡å¼€</button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="panel">
        <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:10px;">
          <div>
            <div style="font-weight:800; font-size:14px;">éš¾åº¦è®¾ç½®</div>
            <div style="color:var(--muted); font-size:12px; margin-top:2px;">è¶Šå¤§è¶Šéš¾ï¼ˆæ ¼å­æ›´å¤šã€å›¾æ¡ˆæ›´å¯†ï¼‰</div>
          </div>
          <div class="chip">ğŸ“± å»ºè®®ï¼šæ‰‹æœºé€‰ 8Ã—10</div>
        </div>

        <div style="display:grid; gap:10px;">
          <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px;">
            <button class="secondary" data-size="6x8">ç®€å• 6Ã—8</button>
            <button class="secondary" data-size="8x10">æ ‡å‡† 8Ã—10</button>
            <button class="secondary" data-size="10x12">å›°éš¾ 10Ã—12</button>
            <button class="secondary" data-size="12x14">åœ°ç‹± 12Ã—14</button>
          </div>

          <div style="margin-top:6px; padding:12px; border-radius:16px; background:rgba(255,255,255,.03); border:1px solid rgba(255,255,255,.06);">
            <div style="font-weight:800; font-size:14px; margin-bottom:6px;">è¯´æ˜</div>
            <div style="color:var(--muted); font-size:13px; line-height:1.5;">
              1ï¼‰æœ¬ç‰ˆæœ¬æ”¯æŒç»å…¸â€œâ‰¤2 æ¬¡æ‹å¼¯â€åˆ¤å®šã€‚<br/>
              2ï¼‰ç›˜é¢å¤–å›´é»˜è®¤ç•™ç©ºï¼Œå…è®¸ä»å¤–åœˆç»•çº¿è¿é€šã€‚<br/>
              3ï¼‰å¦‚æœä½ è¦åŠ å…¥å…³å¡/é“å…·/éŸ³æ•ˆ/æ’è¡Œæ¦œï¼Œæˆ‘ä¹Ÿå¯ä»¥ç»§ç»­å¸®ä½ æ‰©å±•ã€‚
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

<script>
(() => {
  // ====== Config ======
  const ICONS = ["ğŸ","ğŸŒ","ğŸ‡","ğŸ“","ğŸ’","ğŸ‘","ğŸ","ğŸ¥","ğŸ‰","ğŸ¥¥","ğŸ¥•","ğŸŒ½","ğŸ”","ğŸŸ","ğŸ•","ğŸ©","ğŸª","ğŸ°","ğŸ«","ğŸ¿","ğŸ§‹","â˜•ï¸","ğŸ§","ğŸ¥¨"];
  const DEFAULT = { rows: 8, cols: 10 }; // æ‰‹æœºæ¨è
  const GAP_PX = 8; // grid gap in CSS

  // ====== State ======
  let rows = DEFAULT.rows;
  let cols = DEFAULT.cols;
  // å†…éƒ¨ä½¿ç”¨ï¼šå¸¦è¾¹æ¡†ç©ºç™½ï¼ˆ+2ï¼‰
  let board = []; // (rows+2) x (cols+2), 0=empty, >0 icon index
  let selected = null; // {r,c,el}
  let removedCount = 0;
  let moves = 0;
  let combo = 0;
  let lastRemoveAt = 0;

  let timer = null;
  let seconds = 0;
  let paused = false;

  // ====== DOM ======
  const gridEl = document.getElementById("grid");
  const wrapEl = document.getElementById("gameWrap");
  const canvas = document.getElementById("line");
  const ctx = canvas.getContext("2d");
  const overlay = document.getElementById("overlay");
  const overlayTitle = document.getElementById("overlayTitle");
  const overlayText = document.getElementById("overlayText");
  const toastEl = document.getElementById("toast");

  const timeEl = document.getElementById("time");
  const movesEl = document.getElementById("moves");
  const leftEl = document.getElementById("left");
  const comboEl = document.getElementById("combo");

  const restartBtn = document.getElementById("restart");
  const restartBtn2 = document.getElementById("restart2");
  const shuffleBtn = document.getElementById("shuffle");
  const hintBtn = document.getElementById("hint");
  const pauseBtn = document.getElementById("pause");
  const resumeBtn = document.getElementById("resume");
  const helpBtn = document.getElementById("help");

  // ====== Utils ======
  const pad2 = (n) => (n < 10 ? "0" + n : "" + n);
  const fmtTime = (s) => `${pad2(Math.floor(s/60))}:${pad2(s%60)}`;
  function toast(msg){
    toastEl.textContent = msg;
    toastEl.classList.add("show");
    setTimeout(()=>toastEl.classList.remove("show"), 1200);
  }

  function setPaused(p, reason="æš‚åœä¸­"){
    paused = p;
    overlay.classList.toggle("show", p);
    pauseBtn.textContent = p ? "ç»§ç»­" : "æš‚åœ";
    overlayTitle.textContent = reason;
    overlayText.textContent = p ? "ç‚¹å‡»ç»§ç»­æˆ–é‡å¼€æ¸¸æˆã€‚" : "";
  }

  function resizeCanvas(){
    const rect = wrapEl.getBoundingClientRect();
    canvas.width = Math.floor(rect.width * devicePixelRatio);
    canvas.height = Math.floor(rect.height * devicePixelRatio);
    canvas.style.width = rect.width + "px";
    canvas.style.height = rect.height + "px";
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
    clearLine();
  }

  function clearLine(){
    const rect = wrapEl.getBoundingClientRect();
    ctx.clearRect(0,0,rect.width,rect.height);
  }

  function drawPath(pathCells){
    // pathCells: list of points in board coords (r,c), including endpoints and turning points
    // convert to pixel center positions of corresponding tiles (inner grid coords)
    clearLine();
    const pts = pathCells.map(p => cellCenterPx(p.r, p.c));
    const rect = wrapEl.getBoundingClientRect();

    ctx.lineWidth = 4;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue("--line").trim() || "#fbbf24";
    ctx.shadowColor = "rgba(0,0,0,.35)";
    ctx.shadowBlur = 10;

    ctx.beginPath();
    ctx.moveTo(pts[0].x, pts[0].y);
    for(let i=1;i<pts.length;i++){
      ctx.lineTo(pts[i].x, pts[i].y);
    }
    ctx.stroke();

    // little circles
    ctx.shadowBlur = 0;
    ctx.fillStyle = ctx.strokeStyle;
    for (const p of pts){
      ctx.beginPath();
      ctx.arc(p.x, p.y, 5, 0, Math.PI*2);
      ctx.fill();
    }

    // auto clear
    setTimeout(clearLine, 170);
  }

  function cellCenterPx(r, c){
    // r,c in board coords (0..rows+1 / 0..cols+1)
    // inner tiles occupy 1..rows and 1..cols
    // for outer border empty cells, we map to nearest edge line outside tiles.
    const rect = gridEl.getBoundingClientRect();
    const gap = GAP_PX;
    const cellW = (rect.width - gap*(cols-1) - 20) / cols; // 20=padding*2 (grid has 10px padding)
    const cellH = (rect.height - gap*(rows-1) - 20) / rows;

    // start from grid padding
    const originX = rect.left - wrapEl.getBoundingClientRect().left + 10;
    const originY = rect.top - wrapEl.getBoundingClientRect().top + 10;

    // clamp r,c to [0..rows+1], [0..cols+1]
    const rr = r;
    const cc = c;

    // For border cells, place centers just outside the grid boundary
    let x, y;
    if (cc === 0) x = originX - gap - cellW/2;
    else if (cc === cols+1) x = originX + (cols-1)*(cellW+gap) + cellW + gap + cellW/2;
    else x = originX + (cc-1)*(cellW+gap) + cellW/2;

    if (rr === 0) y = originY - gap - cellH/2;
    else if (rr === rows+1) y = originY + (rows-1)*(cellH+gap) + cellH + gap + cellH/2;
    else y = originY + (rr-1)*(cellH+gap) + cellH/2;

    return {x, y};
  }

  // ====== Board generation ======
  function initBoard(){
    // choose icon count
    const total = rows * cols;
    if (total % 2 !== 0){
      throw new Error("rows*cols must be even.");
    }
    const kinds = Math.min(ICONS.length, Math.max(6, Math.floor(total / 6)));
    // build pairs
    const values = [];
    for (let i=0;i<total/2;i++){
      const v = (i % kinds) + 1; // 1..kinds
      values.push(v, v);
    }
    // shuffle values
    for (let i=values.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [values[i], values[j]] = [values[j], values[i]];
    }
    // board with border
    board = Array.from({length: rows+2}, ()=> Array(cols+2).fill(0));
    let idx=0;
    for (let r=1;r<=rows;r++){
      for (let c=1;c<=cols;c++){
        board[r][c] = values[idx++];
      }
    }
    removedCount = 0;
    moves = 0;
    combo = 0;
    lastRemoveAt = 0;
    selected = null;

    seconds = 0;
    startTimer();
    updateHUD();
    renderGrid();
    clearLine();
  }

  function renderGrid(){
    gridEl.innerHTML = "";
    gridEl.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
    gridEl.style.gridTemplateRows = `repeat(${rows}, 1fr)`;

    for (let r=1;r<=rows;r++){
      for (let c=1;c<=cols;c++){
        const v = board[r][c];
        const tile = document.createElement("div");
        tile.className = "tile";
        tile.dataset.r = String(r);
        tile.dataset.c = String(c);
        tile.dataset.v = String(v);
        tile.textContent = v ? ICONS[v-1] : "";
        if (!v) tile.classList.add("removed");
        tile.addEventListener("pointerdown", onTileTap, {passive:true});
        gridEl.appendChild(tile);
      }
    }
    requestAnimationFrame(resizeCanvas);
  }

  function getTileEl(r,c){
    const idx = (r-1)*cols + (c-1);
    return gridEl.children[idx];
  }

  // ====== Game logic: path check (<=2 turns) ======
  function isClearLine(r1,c1,r2,c2){
    // same row
    if (r1 === r2){
      const [a,b] = c1 < c2 ? [c1,c2] : [c2,c1];
      for (let c=a+1;c<b;c++){
        if (board[r1][c] !== 0) return false;
      }
      return true;
    }
    // same col
    if (c1 === c2){
      const [a,b] = r1 < r2 ? [r1,r2] : [r2,r1];
      for (let r=a+1;r<b;r++){
        if (board[r][c1] !== 0) return false;
      }
      return true;
    }
    return false;
  }

  function findPath(a, b){
    // a,b are {r,c}, both non-empty, same value
    const r1=a.r, c1=a.c, r2=b.r, c2=b.c;

    // 0 turn
    if (isClearLine(r1,c1,r2,c2)) return [{r:r1,c:c1},{r:r2,c:c2}];

    // 1 turn: via (r1,c2) or (r2,c1)
    const p1 = {r:r1, c:c2};
    if (board[p1.r][p1.c]===0 && isClearLine(r1,c1,p1.r,p1.c) && isClearLine(p1.r,p1.c,r2,c2)){
      return [{r:r1,c:c1}, p1, {r:r2,c:c2}];
    }
    const p2 = {r:r2, c:c1};
    if (board[p2.r][p2.c]===0 && isClearLine(r1,c1,p2.r,p2.c) && isClearLine(p2.r,p2.c,r2,c2)){
      return [{r:r1,c:c1}, p2, {r:r2,c:c2}];
    }

    // 2 turns: scan rows/cols from a outward through empty cells
    // try intermediate points (r1, k) and (k, c1) then connect with 1 turn
    // scan along row r1
    for (let k=0;k<=cols+1;k++){
      if (k===c1) continue;
      if (board[r1][k]!==0) continue;
      if (!isClearLine(r1,c1,r1,k)) continue;
      // now need connect (r1,k) to b with 1 turn: either (r1, c2) or (r2, k)
      const mid1 = {r:r1, c:k};
      // via (r1,c2) -> already checked as 1 turn from a; but now from mid1
      const t1 = {r:r1, c:c2};
      if (board[t1.r][t1.c]===0 && isClearLine(mid1.r,mid1.c,t1.r,t1.c) && isClearLine(t1.r,t1.c,r2,c2)){
        return [{r:r1,c:c1}, mid1, t1, {r:r2,c:c2}].compressTurns();
      }
      const t2 = {r:r2, c:k};
      if (board[t2.r][t2.c]===0 && isClearLine(mid1.r,mid1.c,t2.r,t2.c) && isClearLine(t2.r,t2.c,r2,c2)){
        return [{r:r1,c:c1}, mid1, t2, {r:r2,c:c2}].compressTurns();
      }
    }
    // scan along col c1
    for (let k=0;k<=rows+1;k++){
      if (k===r1) continue;
      if (board[k][c1]!==0) continue;
      if (!isClearLine(r1,c1,k,c1)) continue;
      const mid1 = {r:k, c:c1};
      const t1 = {r:r2, c:c1};
      if (board[t1.r][t1.c]===0 && isClearLine(mid1.r,mid1.c,t1.r,t1.c) && isClearLine(t1.r,t1.c,r2,c2)){
        return [{r:r1,c:c1}, mid1, t1, {r:r2,c:c2}].compressTurns();
      }
      const t2 = {r:k, c:c2};
      if (board[t2.r][t2.c]===0 && isClearLine(mid1.r,mid1.c,t2.r,t2.c) && isClearLine(t2.r,t2.c,r2,c2)){
        return [{r:r1,c:c1}, mid1, t2, {r:r2,c:c2}].compressTurns();
      }
    }

    // Another robust approach: scan all empty cross points (r, c) with 2-turn check
    // (a -> (r, c1)) line, (r, c1)->(r, c2) line, (r, c2)->b line
    for (let r=0;r<=rows+1;r++){
      if (board[r][c1]!==0) continue;
      if (!isClearLine(r1,c1,r,c1)) continue;
      for (let c=0;c<=cols+1;c++){
        if (board[r][c]!==0) continue;
        // we try corners: (r,c1)->(r,c) and (r,c)->(r2,c2) with 1 turn
        if (!isClearLine(r,c1,r,c)) continue;
        // now from (r,c) to b with <=1 turn
        // direct
        if (isClearLine(r,c,r2,c2)) return [{r:r1,c:c1},{r:r,c:c1},{r:r,c:c},{r:r2,c:c2}].compressTurns();
        // one turn
        const k1 = {r:r, c:c2};
        if (board[k1.r][k1.c]===0 && isClearLine(r,c,k1.r,k1.c) && isClearLine(k1.r,k1.c,r2,c2)){
          return [{r:r1,c:c1},{r:r,c:c1},{r:r,c:c},{r:k1.r,c:k1.c},{r:r2,c:c2}].compressTurns();
        }
        const k2 = {r:r2, c:c};
        if (board[k2.r][k2.c]===0 && isClearLine(r,c,k2.r,k2.c) && isClearLine(k2.r,k2.c,r2,c2)){
          return [{r:r1,c:c1},{r:r,c:c1},{r:r,c:c},{r:k2.r,c:k2.c},{r:r2,c:c2}].compressTurns();
        }
      }
    }
    return null;
  }

  // compress collinear consecutive points
  Array.prototype.compressTurns = function(){
    const pts = this;
    if (pts.length <= 2) return pts;
    const out = [pts[0]];
    for (let i=1;i<pts.length-1;i++){
      const a = out[out.length-1];
      const b = pts[i];
      const c = pts[i+1];
      const collinear = (a.r===b.r && b.r===c.r) || (a.c===b.c && b.c===c.c);
      if (!collinear) out.push(b);
    }
    out.push(pts[pts.length-1]);
    return out;
  }

  // ====== Interaction ======
  function onTileTap(ev){
    if (paused) return;
    const el = ev.currentTarget;
    const r = Number(el.dataset.r);
    const c = Number(el.dataset.c);
    const v = board[r][c];
    if (!v) return;

    // same tile
    if (selected && selected.r===r && selected.c===c){
      deselect();
      return;
    }

    if (!selected){
      select(r,c,el);
      return;
    }

    // second selection
    const a = {r:selected.r, c:selected.c};
    const b = {r, c};

    if (board[a.r][a.c] !== v){
      // different icon
      flashBad(selected.el);
      flashBad(el);
      deselect();
      toast("å›¾æ¡ˆä¸åŒï¼Œä¸èƒ½æ¶ˆé™¤");
      return;
    }

    // same icon, check path
    const path = findPath(a,b);
    moves++;
    updateHUD();

    if (!path){
      flashBad(selected.el);
      flashBad(el);
      deselect();
      toast("è¿çº¿ä¸é€šï¼ˆâ‰¤2 æ¬¡æ‹å¼¯ï¼‰");
      return;
    }

    // remove
    drawPath(path);
    removePair(a,b);
    deselect();
    checkWinOrDead();
  }

  function select(r,c,el){
    selected = {r,c,el};
    el.classList.add("selected");
  }
  function deselect(){
    if (selected?.el) selected.el.classList.remove("selected");
    selected = null;
  }
  function flashBad(el){
    el.classList.add("bad");
    setTimeout(()=>el.classList.remove("bad"), 240);
  }

  function removePair(a,b){
    board[a.r][a.c] = 0;
    board[b.r][b.c] = 0;
    const ea = getTileEl(a.r,a.c);
    const eb = getTileEl(b.r,b.c);
    ea.classList.add("removed");
    eb.classList.add("removed");

    removedCount += 2;

    // combo (within 1.2s)
    const now = Date.now();
    if (now - lastRemoveAt <= 1200) combo++;
    else combo = 1;
    lastRemoveAt = now;

    updateHUD();
    toast(combo >= 3 ? `è¿æ¶ˆ x${combo}ï¼` : "æ¶ˆé™¤æˆåŠŸ");
  }

  // ====== Hint / Shuffle / Solvability ======
  function getAllTiles(){
    const tiles = [];
    for (let r=1;r<=rows;r++){
      for (let c=1;c<=cols;c++){
        const v = board[r][c];
        if (v) tiles.push({r,c,v});
      }
    }
    return tiles;
  }

  function findAnyPair(){
    const tiles = getAllTiles();
    // group by value
    const map = new Map();
    for (const t of tiles){
      if (!map.has(t.v)) map.set(t.v, []);
      map.get(t.v).push(t);
    }
    for (const [v, arr] of map){
      for (let i=0;i<arr.length;i++){
        for (let j=i+1;j<arr.length;j++){
          const path = findPath({r:arr[i].r,c:arr[i].c},{r:arr[j].r,c:arr[j].c});
          if (path) return {a:arr[i], b:arr[j], path};
        }
      }
    }
    return null;
  }

  function doHint(){
    if (paused) return;
    const found = findAnyPair();
    if (!found){
      toast("å½“å‰æ— å¯æ¶ˆé™¤å¯¹ï¼Œè¯•è¯•æ´—ç‰Œ");
      return;
    }
    const ea = getTileEl(found.a.r, found.a.c);
    const eb = getTileEl(found.b.r, found.b.c);
    ea.classList.add("selected");
    eb.classList.add("selected");
    drawPath(found.path);
    setTimeout(()=>{
      ea.classList.remove("selected");
      eb.classList.remove("selected");
    }, 420);
    toast("å·²æç¤ºä¸€å¯¹å¯æ¶ˆé™¤");
  }

  function doShuffle(){
    if (paused) return;
    const tiles = getAllTiles();
    const values = tiles.map(t=>board[t.r][t.c]);
    // shuffle values
    for (let i=values.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [values[i], values[j]] = [values[j], values[i]];
    }
    // put back
    let idx=0;
    for (const t of tiles){
      board[t.r][t.c] = values[idx++];
    }
    // re-render just texts
    for (let r=1;r<=rows;r++){
      for (let c=1;c<=cols;c++){
        const el = getTileEl(r,c);
        const v = board[r][c];
        el.dataset.v = String(v);
        el.textContent = v ? ICONS[v-1] : "";
        if (!v) el.classList.add("removed");
        else el.classList.remove("removed");
        el.classList.remove("selected");
      }
    }
    deselect();
    toast("å·²æ´—ç‰Œ");
    // if still dead, try a few times
    let tries=0;
    while(!findAnyPair() && tries<8){
      tries++;
      // reshuffle again
      for (let i=values.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [values[i], values[j]] = [values[j], values[i]];
      }
      idx=0;
      for (const t of tiles){
        board[t.r][t.c] = values[idx++];
      }
      for (let r=1;r<=rows;r++){
        for (let c=1;c<=cols;c++){
          const el = getTileEl(r,c);
          const v = board[r][c];
          el.dataset.v = String(v);
          el.textContent = v ? ICONS[v-1] : "";
          if (!v) el.classList.add("removed");
          else el.classList.remove("removed");
          el.classList.remove("selected");
        }
      }
    }
    if (!findAnyPair() && removedCount < rows*cols){
      toast("ä»æ— è§£ï¼Œå»ºè®®é‡å¼€");
    }
  }

  function checkWinOrDead(){
    const left = rows*cols - removedCount;
    if (left === 0){
      stopTimer();
      setPaused(true, "ğŸ‰ é€šå…³å•¦ï¼");
      overlayText.textContent = `ç”¨æ—¶ ${fmtTime(seconds)}ï¼Œæ­¥æ•° ${moves}ã€‚ç‚¹å‡»é‡å¼€å†æ¥ä¸€å±€ã€‚`;
      return;
    }
    // dead?
    const any = findAnyPair();
    if (!any){
      toast("å½“å‰å¯èƒ½æ— è§£ï¼Œå»ºè®®æ´—ç‰Œ");
    }
  }

  // ====== Timer / HUD ======
  function startTimer(){
    stopTimer();
    timer = setInterval(()=>{
      if (!paused){
        seconds++;
        timeEl.textContent = fmtTime(seconds);
      }
    }, 1000);
    timeEl.textContent = fmtTime(seconds);
  }
  function stopTimer(){
    if (timer) clearInterval(timer);
    timer = null;
  }
  function updateHUD(){
    movesEl.textContent = String(moves);
    comboEl.textContent = String(combo);
    leftEl.textContent = String(rows*cols - removedCount);
    timeEl.textContent = fmtTime(seconds);
  }

  // ====== Buttons ======
  restartBtn.addEventListener("click", ()=>{ setPaused(false); initBoard(); toast("å·²é‡å¼€"); });
  restartBtn2.addEventListener("click", ()=>{ setPaused(false); initBoard(); toast("å·²é‡å¼€"); });
  shuffleBtn.addEventListener("click", doShuffle);
  hintBtn.addEventListener("click", doHint);
  pauseBtn.addEventListener("click", ()=>{
    setPaused(!paused, paused ? "" : "æš‚åœä¸­");
  });
  resumeBtn.addEventListener("click", ()=>setPaused(false));

  helpBtn.addEventListener("click", ()=>{
    setPaused(true, "ç©æ³•è¯´æ˜");
    overlayText.textContent =
      "é€‰æ‹©ä¸¤å¼ ç›¸åŒå›¾æ¡ˆçš„æ–¹å—ï¼Œå¦‚æœå®ƒä»¬ä¹‹é—´èƒ½ç”¨ä¸è¶…è¿‡ 2 æ¬¡æ‹å¼¯è¿çº¿ï¼ˆè·¯å¾„åªèƒ½ç»è¿‡ç©ºç™½æ ¼æˆ–å¤–å›´ç©ºç™½ï¼‰ï¼Œå³å¯æ¶ˆé™¤ã€‚\n\n" +
      "æç¤ºï¼šé«˜äº®ä¸€å¯¹å¯æ¶ˆé™¤ï¼›æ´—ç‰Œï¼šé‡æ–°æ‰“ä¹±å‰©ä½™æ–¹å—ä½ç½®ã€‚";
  });

  document.querySelectorAll("button[data-size]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const [r,c] = btn.dataset.size.split("x").map(Number);
      rows = r; cols = c;
      setPaused(false);
      initBoard();
      toast(`å·²åˆ‡æ¢ï¼š${rows}Ã—${cols}`);
    });
  });

  // ====== Resize handling ======
  window.addEventListener("resize", ()=>resizeCanvas(), {passive:true});
  window.addEventListener("orientationchange", ()=>setTimeout(resizeCanvas, 200), {passive:true});

  // Prevent double-tap zoom issues in some browsers (light)
  document.addEventListener("dblclick", (e)=>e.preventDefault(), {passive:false});

  // ====== Start ======
  initBoard();
})();
</script>
</body>
</html>
